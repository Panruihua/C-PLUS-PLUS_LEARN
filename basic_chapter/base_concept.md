# concept
## initialization
变量初始化使用符号“=”是比较传统的形式，最早被C语言使用。在C++中提供了更加通用的形式，使用“{}”花括号：  
```
int d1 = 2;  
int d2 {3};    
int d3 = {4};
```  
以上都可以完成初始化，不过在C++中首推使用花括号进行初始化，为什么？  
```
int d1 = 2.1; // output 2
int d2 {2.1}; // error: narrowing conversion of '2.1000000000000001e+0' from 'double' to 'int'
```
d1是int型，依然给它赋值浮点型，可以编译通过，不过输出是2，编译器将浮点型截断成整型。  
而d2为何无法编译通过呢？因为我们使用了列表初始化（List Initialization）,它具有更严格的类型检查，发生隐式类型转换可能导致数据丢失时，编译器会拒绝这一转换，从而编译失败。  
在C++中初始化要尽可能使用花括号列表初始化来对变量初始化，假如不小心出现**截断**，编译器会拒绝，从而开发者就能发现问题。  

常量在声明时必须进行初始化。  
普通变量在声明时也尽可能初始化，除非在极其有限条件下不初始化。在定义一个变量时，如果变量类型可以由初始化器推断出来，则无须显式指定类型,使用auto：
```
auto b {true};
auto a {2};
auto c {2.2};
```  
除非有明显理由，才显式指定类型，理由包括：  
- 该定义位于一个较大作用域中，我们希望代码读者清楚地知道其类型；
- 我们希望明确规定某个变量的范围和精度。  
> 通过使用auto可以帮助我们避免荣誉，并且无须再书写长类型名。这点在泛型编程中尤其重要，因为在泛型编程中程序员很难知道对象确切类型，况且类型名字可能相当的长。  




## constant

- const:“承诺不改变这个值”，主要用于说明接口，这样把变量传入函数就不必担心变量会在函数内被改变。编译器负责确认并执行const的承诺。
- constexpr:“在编译时求值”，主要用于说明常量，作用是允许将数据置于只读内存中（不太可能被破坏）以及提升性能。  

constexpr修饰变量或者函数时，就是要求编译器在编译时就确定该表达式的值。修改函数时要确保函数参数也是常量表达式，这点需要遵循。若参数的参数是运行时确定，那该修饰符就没有意义了。  

