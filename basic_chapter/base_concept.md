# concept
## initialization
初始化器是对象在初始状态下被赋予的值。初始化器有四种可能的形式:  
```
X a1 {v};
X a2 = {v};
X a3 = v;
X a4(v4);
```
上面的四种形式，只有第一种不受任何限制，在所有场景都能使用。因此C++之父强烈建议程序员使用第一种形式。它的好处在于含义清晰，与其他形式相比不太容易出错。

变量初始化使用符号“=”是比较传统的形式，最早被C语言使用。在C++中提供了更加通用的形式，使用“{}”花括号：  
```
int d1 = 2;  
int d2 {3};    
int d3 = {4};
```  
以上都可以完成初始化，不过在C++中首推使用花括号进行初始化，为什么？  
```
int d1 = 2.1; // output 2
int d2 {2.1}; // error: narrowing conversion of '2.1000000000000001e+0' from 'double' to 'int'
```
d1是int型，依然给它赋值浮点型，可以编译通过，不过输出是2，编译器将浮点型截断成整型。  
而d2为何无法编译通过呢？因为我们使用了列表初始化（List Initialization）,它具有更严格的类型检查，发生隐式类型转换可能导致数据丢失时，编译器会拒绝这一转换，从而编译失败。  
在C++中初始化要尽可能使用花括号列表初始化来对变量初始化，假如不小心出现**截断**，编译器会拒绝，从而开发者就能发现问题。  

常量在声明时必须进行初始化。  

普通变量在声明时也尽可能初始化，除非在极其有限条件下不初始化。  
在定义一个变量时，如果变量类型可以由初始化器推断出来，则无须显式指定类型,使用auto：
```
auto b {true};
auto a {2};
auto c {2.2};
```  
除非有明显理由，才显式指定类型，理由包括：  
- 该定义位于一个较大作用域中，我们希望代码读者清楚地知道其类型；
- 我们希望明确规定某个变量的范围和精度。  
> 通过使用auto可以帮助我们避免冗余，并且无须再书写长类型名。这点在泛型编程中尤其重要，因为在泛型编程中程序员很难知道对象确切类型，况且类型名字可能相当的长。  

另外，当我们使用auto关键字从初始化器推断变量的类型时，没必要再采用{}列表初始化的方式了。为啥?因为{}的类型是initializer_list<>,使用auto推断出来的类型就不是预想的那样了。如:  
```
auto z1 {99}; //推断出来类型initializer_list<int>
auto z2 = 99; //推断出来类型int
```  
因此当使用auto的时候应该选择使用 = 的初始化形式。


**最坏情况下**  
假如程序员就没有指定初始化器，会发生什么呢？
**全局变量**、**名字空间变量**、**局部static变量**和**static成员**，会执行相应数据类型的列表{}初始化；比如
```
int a; //等同于'int a{}', 因此a 的值为0
double d; //等同于"double d{}",因此d的值变为0.0
```
对于**局部变量**和**自由存储上的对象**（有时也称为动态对象或者堆对象），除非它们位于用户自定义类型的默认构造函数中，否则不会执行默认初始化。  

## constant
- const:“承诺不改变这个值”，主要用于说明接口，这样把变量传入函数就不必担心变量会在函数内被改变。编译器负责确认并执行const的承诺。
- constexpr:“在编译时求值”，主要用于说明常量，作用是允许将数据置于只读内存中（不太可能被破坏）以及提升性能。  

constexpr修饰变量或者函数时，就是要求编译器在编译时就确定该表达式的值。修改函数时要确保函数参数也是常量表达式，这点需要遵循。若参数的参数是运行时确定，那该修饰符就没有意义了。  
## struct 结构 
### 内存布局
1. 在struct的对象中，成员按照声明顺序依次存放。  
2. 一个struct对象的大小不一定恰好等于它所有元素大小的累积之和，因为机器要求内存对齐。  
比如下面的struct要使用12个字节：  

类型 | column1 | column2 | column3  | column4
------- | ------- | ------- | -------  | -------
char: |* | 
int: | * | * | * | * | 
char: |* |

因此，在设计struct时，要考虑到内存对齐下的内存空间使用效率，稍微优化下上面的struct内存分配，使用8个字节：  

类型 | column1 | column2 | column3  | column4
------- | ------- | ------- | -------  | -------
int: | * | * | * | * | 
char,char: |* | * |

  
## 显示类型转换
static_cast:执行关联类型之间的转换，比如一种指针类型向同一个类层次中其他指针类型的转换，或者整数类型向枚举类型的转换，或者浮点类型向整数类型的转换。它还能指针构造函数和转换运算符定义的类型转换。  

reinterpret_cast:处理非关联类型之间的转换，比如整数向指针的转换以及指针向另一个非关联指针类型的转换。  

const_cast:参与转换的类型仅在const修饰符及volatile修饰符上有所区别。  

dynamic_cast:参与转换的类型或者引用向类层次体系的类型转换，并执行运行时检查。  


Bjarne Stroustrup认为几乎无法为reinterpret_cast担保任何事，reinterpret_cast必须作用于函数指针。

```cpp
    char x = 'a'; //err:不存在char* 向int*隐式类型转换
    int* p1 = &x; //err：不存在char* 向int* 隐式类型转换
    int* p2 = static_cast<int*>(&x); //OK:程序员责任自负
    int* p3 = reinterpret_cast<int*>(&x);
    struct B{};
    struct D : B{};
    B* pb = new D; //OK: D*向B*的隐式类型转换
    D* pd = pd; //err: 不存在B*向D*的隐式类型转换
    D* pd = static_cast<D*>(pd); //OK

```


# 函数
## constexpr函数
当constexpr出现在函数定义中时，它的含义是“如果给定了常量表达式作为实参，则该函数应该能用在常量表达式中”。    
当constexpr出现在对象定义中时，它的含义是“在编译时对初始化器求值”。  
函数必须足够简单才能在编译时求值：constexpr函数必须包含一条独立的return语句，没有循环，也没有局部变量。  
并且constexpr函数不能有副作用。也就是说constexpr函数应该是一个纯函数。  

与普通constexpr函数相比，constexpr构造函数规则有所区别：只允许简单执行成员初始化操作。  

constexpr函数允许递归和条件表达式。  

必须严格遵循constexpr函数使用习惯，不然编译时间会变大很长，调试难度也很大。  



```cpp
/*所谓副作用，是指函数除了返回结果之外还对外部状态产生影响，
比如修改全局变量、类的成员变量、或进行I/O操作等。*/


//err 不能是void
int glob;
constexpr void bad1(int a) {    //err:不能是void
    glob = a;   //err:在constexpr函数中有副作用
}

//err1 在constexpr函数中有if语句
constexpr int bad2(int a) {
    if(a >= 0) //err
        return a;
    else
        return -a;
}

//err1 在constexpr函数中有局部变量
//err2 在constexpr函数中使用for循环
constexpr int bad3(int a) {
    sum = 0; //err1
    for(int i = 0; i < a; +=i) //err2
        sum += fac(i);
    return sum;
}
```

## [[noreturn]]函数
在C++中，[[noreturn]] 是一种属性（attribute），用于标注那些不会返回的函数。  
它告诉编译器该函数在调用后不会再返回到调用它的地方，通常是因为函数会导致程序终止或进入无限循环。  
[[noreturn]] 属性主要用于提高代码的可读性和帮助编译器进行优化。  
```cpp
[[noreturn]] void func();
```
### 使用场景  
[[noreturn]] 通常用于那些永远不会返回的函数，例如：  
1. 程序终止函数，比如 exit()。  
2. 抛出异常的函数。  
3. 无限循环的函数。  
### [[noreturn]]的作用
1. 提高代码可读性：标记某些函数不会返回有助于代码维护，使其他开发人员明确知道函数的行为。  
2. 编译器优化：编译器可以利用这一属性进行优化，比如省略一些不必要的清理或警告。  
3. 避免警告：编译器在知道某函数不会返回时，会避免产生一些多余的警告。  
例如，当函数返回类型不是 void 时而没有返回语句时，编译器通常会发出警告，但使用 [[noreturn]] 可以避免这种情况。  

### 注意事项
1. 返回类型：虽然 [[noreturn]] 函数可以使用任何返回类型，但实际上不应该返回任何值。  
如果在一个带有 [[noreturn]] 的函数中加入返回语句，行为是未定义的（UB，Undefined Behavior）。  
2. 无效使用：不要随便在可能返回的函数上使用 [[noreturn]]，否则会引起未定义行为或编译错误。  




